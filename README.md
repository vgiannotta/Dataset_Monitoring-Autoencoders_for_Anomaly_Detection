{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "9ad99844-b6ce-4958-b7be-1ce11d87a1f5",
   "metadata": {},
   "source": [
    "### README"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "483df613-2ecd-40bd-9497-972e282b2809",
   "metadata": {},
   "source": [
    "# Autoencoders for Anomaly Detection: Using Deep Learning Methods to Monitor the Health of Automated Datasets  \n",
    "\n",
    "-----  \n",
    "\n",
    "### What is this project?  \n",
    "This proposal and proof of concept is a Tyler Tech hackweek project from 2023. The datasets discussed here are data assets that are housed in Tyler customer SaaS platforms as tabular datasets. In the use case described below, datasets are hosted and published in a given customer environment, and have accompanying ETL implemented such that data from their system of record – a separate database hosted elsewhere – is pulled into the Tyler dataset on a given cadence through a scheduled process. The scheduled process is itself another Tyler product, which connects source systems to the Tyler environment, so that data can be visualized and shared.  \n",
    "\n",
    "The steps outlined in the _Building a Proof of Concept_ section below are laid out as a proposal for a future project to build out this dataset monitoring feature in a test environment. The notebooks contained in thie repo, however, are preliminary research, intended to answer a few foundational questions about whether we can and should pursue development of this feature.  \n",
    "\n",
    "Ultimately, the performance of this autoencoder was not great – accuracy score peaked at around 45% with a peak recall rate of 85%. I believe that with additional optimization, this could be a viable method of monitoring updates to automated datasets. This was a project that was time-boxed to about a week of development, which included the data collection process, so I had a lot of additional ideas for ways to track and improve model performance that are not implemented here. Those next steps are documented at the end of the `Preprocessing and Modeling` notebook.   \n",
    "\n",
    "_Some details in this project – like details about the source data – have been omitted for privacy._  \n",
    "\n",
    "-----  \n",
    "\n",
    "\n",
    "### Problem\n",
    "\n",
    "Can we build infrastructure/services that monitor the health of a scheduled dataset?\n",
    "\n",
    "### Use Case\n",
    "\n",
    "Our customers often automate datasets that are connected to their own source databases. These datasets are updated automatically, based on some specified cadence. Update failures, when they happen, are typically due to schema mismatches -- when the update data doesn't match the existing dataset in schema -- or connectivity issues to the source system. These errors are caught and made obvious by our established error handling infrastructure.\n",
    "\n",
    "There are however cases where an update can be faulty in terms of the *content* being published -- fewer rows than expected, erroneous values in a column, etc. -- and there is currently no tracking or error handling available to monitor for these types of issues. In other words, an update can run successfully, and the dataset can publish as expected, but the content of the data is inaccurate. Downstream metrics, vizzes, and reports will be inaccurate as well.\n",
    "\n",
    "Today, in order to validate the content of dataset updates, customers have to query their datasets themselves, and then proceed to compare the data to a previous update, or to data from the source system (or some other, likely manual, QA process).\n",
    "\n",
    "This method of issue remediation is costly. Customers must be proactive in monitoring their updates by establishing their own manual, labor-intensive QA process. Internally, Data Integrations spends more time troubleshooting data issues; because these \"silent failures\" often originate from the customer source system, DI engineers must investigate database architecture remotely, with little to no knowledge of or access to the database itself.\n",
    "\n",
    "Can we instead provide an opt-in service that automatically checks a dataset each time an update is published in the platform? The service would assess the dataset for completeness, obvious anomalies, or other inconsistencies that we prioritize. If health checks don't pass, the customer can be alerted by the service that their dataset may not have updated properly and take action.  \n",
    "\n",
    "### Preliminary Research  \n",
    "\n",
    "Research should be done initially to understand a few foundational questions:  \n",
    "- Is there enough metadata about dataset updates available through Tyler APIs to track the health of scheduled datasets?  \n",
    "    - If not, can this metadata be bootstrapped in such a way that we can use it to train a model that will reflect real-world scenarios?\n",
    "- Can we get to a clear definition of what an anomaly means in this specific context of expected vs unexpected updates?\n",
    "- Are there models other than autoencoders that are appropriate for this problem?\n",
    "\n",
    "### Building a Proof of Concept: Tasks for the Build\n",
    "\n",
    "The testing process and development process for a net-new monitoring service are linked, in that we will need to build an MVP of the service before we can fully understand the requirements to build in production. The approach laid out here is expected to be iterative and change along the way, but at a high level, the testing and development process can be broken out into phases:\n",
    "\n",
    "1.  **Collect test data**\n",
    "    1.  In order to understand whether we *can* implement automated dataset monitoring, we need to know which specific events to monitor for, and how to obtain comprehensive data on these events.\n",
    "        1.  Tasks:\n",
    "            1.  Identify monitoring criteria.\n",
    "            2.  Collect a sample of the data. The sample should represent the dataset in its healthy state, as well as in an error state. If possible, the proportion of healthy observations to erroneous ones in the sample should be as realistic as possible. If the anomaly event is rare, there should only be a small number of errors in the sample, and a large number of \"valid\" records.  \n",
    "2.  **Create test environment**\n",
    "    1.  What IT resources are needed for testing? Can this be done with a demo domain and a local dev environment?\n",
    "        1.  Tasks:\n",
    "            1.  Identify and set up testing framework\n",
    "3.  **Create archive dataset** (first time only)\n",
    "    1.  In order to monitor a dataset, we need to begin capturing metadata on the dataset each time an update happens. Dataset metadata will be captured in an archive dataset which lives on the same domain as the dataset to be monitored.\n",
    "        1.  Tasks:\n",
    "            1.  Define the metadata that should be captured on the dataset.\n",
    "            2.  Create a script that generates an archive dataset for the dataset being monitored, where each column is a specific piece of metadata.\n",
    "4.  **Capture updates**\n",
    "    1.  Each time the monitored dataset undergoes an update, the archive repository dataset should capture metadata on the updates.\n",
    "        1.  Tasks:\n",
    "            1.  Create a script that runs whenever an update is made to the monitored dataset. The script should capture any of the defined pieces of metadata and append them to the archive repository dataset.\n",
    "5.  **Analyze updates**\n",
    "    1.  With each update of the monitored dataset, analyze the archive data and determine the health of the dataset.\n",
    "        1.  Tasks:\n",
    "            1.  Set up model competition and analyze performance\n",
    "                1.  PCA\n",
    "                2.  Some kind of random forest?\n",
    "                3.  Some kind of neural network?\n",
    "                4.  Naive methods?\n",
    "            2.  Write script to assess the latest dataset update for health, using the best modeling method/s from the model competition. The archive history records are used as training data, and the most recent archive record is the test.\n",
    "            3.  Write the data from model assessment to a dataset? Maybe back to the archive dataset?\n",
    "                1.  Could be interesting to create a viz from the results\n",
    "6.  **If anomaly is detected, notify dataset owners**\n",
    "    1.  The notification method is dependent on customer needs, and also on the implementation path; do we need input from the customer in order to start this service on their domain, or can we just \"turn on\" the service?\n",
    "        1.  It should be said that this is a service meant to empower the dataset owners. The expectation is that customers will use this tool to monitor their own datasets. We internally take on the responsibility of monitoring the monitoring service, but we do not monitor datasets for the customer.\n",
    "        2.  Considering this, I strongly recommend that we have a requirements-gathering exchange with the customer as a pre-req for turning on the service. This would be a stop-gap to ensure that there is an agreement of customer ownership, giving us the ability to designate a real person who will receive and be custodian of any notifications.\n",
    "7.  **Operationalize**\n",
    "    1.  Scripts can run in Airflow, with the DAG cadence set to one of the following:\n",
    "        1.  A brief time after the dataset is regularly scheduled to update\n",
    "            1.  pros:\n",
    "                1.  The job only runs as often as necessary\n",
    "            2.  cons:\n",
    "                1.  If a dataset takes too long to finish updating, the DAG could kick off before the update is complete, thereby missing the newest data\n",
    "                2.  Manual data pulls would not be caught until the next scheduled runtime\n",
    "        2.  Very frequently\n",
    "            1.  pros:\n",
    "                1.  We catch way more of the updates faster\n",
    "                2.  If any of the scripts takes a long time / heavy resources to execute, the DAG could fail more often\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "62b4ea78-5a41-4a97-952d-13e8e94acabc",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
